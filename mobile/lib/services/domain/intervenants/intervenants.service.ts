/**
 * Service de gestion des intervenants - AgriConnect
 * Extrait du CollecteService avec int√©gration du cache intelligent
 */

import { SupabaseClient } from '@supabase/supabase-js';
import { supabase } from '../../../../lib/supabase-client';  
import { IntervenantsCache } from './intervenants.cache';
import {
  Intervenant,
  IntervenantDisplay,
  IntervenantUpdateData,
  IntervenantInsert,
  IntervenantServiceOptions
} from './intervenants.types';

class IntervenantsService {
  private supabase: SupabaseClient = supabase;
  private cache = new IntervenantsCache();

  /**
   * R√©cup√®re tous les intervenants d'une parcelle avec cache
   */
  async getIntervenantsByPlotId(
    plotId: string,
    options: IntervenantServiceOptions = {}
  ): Promise<IntervenantDisplay[]> {
    const { useCache = true, cacheTTL, refreshCache = false } = options;

    console.log('üë• [IntervenantsService] R√©cup√©ration des intervenants pour la parcelle:', plotId);

    // V√©rifier le cache si activ√©
    if (useCache && !refreshCache) {
      const cachedIntervenants = await this.cache.getPlotIntervenants(plotId);
      if (cachedIntervenants) {
        console.log(`‚ö° [IntervenantsService] Cache HIT: ${cachedIntervenants.length} intervenants pour la parcelle ${plotId}`);
        // Convertir en display format
        return cachedIntervenants.map(intervenant => this.formatIntervenantDisplay(intervenant));
      }
      console.log(`‚ùå [IntervenantsService] Cache MISS pour les intervenants de la parcelle ${plotId}`);
    }

    try {
      const startTime = Date.now();
      
      const { data, error } = await this.supabase
        .from('participants')
        .select('*')
        .eq('plot_id', plotId)
        .order('created_at', { ascending: true });

      if (error) {
        console.error('‚ùå [IntervenantsService] Erreur lors de la r√©cup√©ration des intervenants:', error);
        throw error;
      }

      const responseTime = Date.now() - startTime;
      console.log(`‚úÖ [IntervenantsService] ${data?.length || 0} intervenants r√©cup√©r√©s en ${responseTime}ms`);

      const intervenants = (data || []).map((intervenant: any) => this.formatIntervenantData(intervenant));
      const intervenantsDisplay = intervenants.map(intervenant => this.formatIntervenantDisplay(intervenant));

      // Mettre en cache si activ√©
      if (useCache && intervenants.length > 0) {
        await this.cache.setPlotIntervenants(plotId, intervenants, typeof cacheTTL === 'string' ? undefined : cacheTTL);
      }

      return intervenantsDisplay;
    } catch (error) {
      console.error('‚ùå [IntervenantsService] Erreur lors de la r√©cup√©ration des intervenants:', error);
      throw error;
    }
  }

  /**
   * R√©cup√®re un intervenant par son ID avec cache
   */
  async getIntervenantById(
    intervenantId: string,
    options: IntervenantServiceOptions = {}
  ): Promise<Intervenant | null> {
    const { useCache = true, cacheTTL, refreshCache = false } = options;

    console.log('üîç [IntervenantsService] R√©cup√©ration de l\'intervenant:', intervenantId);

    // V√©rifier le cache si activ√©
    if (useCache && !refreshCache) {
      const cachedIntervenant = await this.cache.getIntervenant(intervenantId);
      if (cachedIntervenant) {
        console.log(`‚ö° [IntervenantsService] Cache HIT pour l'intervenant ${intervenantId}`);
        return cachedIntervenant;
      }
      console.log(`‚ùå [IntervenantsService] Cache MISS pour l'intervenant ${intervenantId}`);
    }

    try {
      const startTime = Date.now();
      
      const { data, error } = await this.supabase
        .from('participants')
        .select('*')
        .eq('id', intervenantId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          console.log(`‚ùå [IntervenantsService] Intervenant ${intervenantId} non trouv√©`);
          return null;
        }
        console.error('‚ùå [IntervenantsService] Erreur lors de la r√©cup√©ration de l\'intervenant:', error);
        throw error;
      }

      const responseTime = Date.now() - startTime;
      console.log(`‚úÖ [IntervenantsService] Intervenant r√©cup√©r√© en ${responseTime}ms`);

      const intervenant = this.formatIntervenantData(data);

      // Mettre en cache si activ√©
      if (useCache && intervenant) {
        await this.cache.setIntervenant(intervenantId, intervenant, typeof cacheTTL === 'string' ? undefined : cacheTTL);
      }

      return intervenant;
    } catch (error) {
      console.error('‚ùå [IntervenantsService] Erreur lors de la r√©cup√©ration de l\'intervenant:', error);
      throw error;
    }
  }

  /**
   * Cr√©e un nouvel intervenant et invalide le cache
   */
  async createIntervenant(
    intervenantData: IntervenantInsert,
    options: IntervenantServiceOptions = {}
  ): Promise<Intervenant> {
    console.log('‚ûï [IntervenantsService] Cr√©ation d\'un nouvel intervenant:', intervenantData);

    try {
      const startTime = Date.now();
      
      const { data, error } = await this.supabase
        .from('participants')
        .insert(intervenantData)
        .select()
        .single();

      if (error) {
        console.error('‚ùå [IntervenantsService] Erreur lors de la cr√©ation de l\'intervenant:', error);
        throw error;
      }

      if (!data) {
        throw new Error('Aucune donn√©e retourn√©e apr√®s la cr√©ation de l\'intervenant');
      }

      const responseTime = Date.now() - startTime;
      console.log(`‚úÖ [IntervenantsService] Intervenant cr√©√© en ${responseTime}ms`);

      const intervenant = this.formatIntervenantData(data);

      // Invalider le cache
      await this.cache.invalidatePlotCache(intervenant.plot_id);
      await this.cache.invalidateAgentCache(intervenant.created_by || '');

      return intervenant;
    } catch (error) {
      console.error('‚ùå [IntervenantsService] Erreur lors de la cr√©ation de l\'intervenant:', error);
      throw error;
    }
  }

  /**
   * Met √† jour un intervenant et invalide le cache
   */
  async updateIntervenant(
    intervenantId: string,
    updateData: IntervenantUpdateData,
    options: IntervenantServiceOptions = {}
  ): Promise<Intervenant> {
    console.log('‚úèÔ∏è [IntervenantsService] Mise √† jour de l\'intervenant:', intervenantId);

    try {
      const startTime = Date.now();
      
      const { data, error } = await this.supabase
        .from('participants')
        .update(updateData)
        .eq('id', intervenantId)
        .select()
        .single();

      if (error) {
        console.error('‚ùå [IntervenantsService] Erreur lors de la mise √† jour de l\'intervenant:', error);
        throw error;
      }

      if (!data) {
        throw new Error('Aucune donn√©e retourn√©e apr√®s la mise √† jour de l\'intervenant');
      }

      const responseTime = Date.now() - startTime;
      console.log(`‚úÖ [IntervenantsService] Intervenant mis √† jour en ${responseTime}ms`);

      const intervenant = this.formatIntervenantData(data);

      // Invalider le cache
      await this.cache.invalidateIntervenantCache(intervenantId);
      await this.cache.invalidatePlotCache(intervenant.plot_id);
      await this.cache.invalidateAgentCache(intervenant.created_by || '');

      return intervenant;
    } catch (error) {
      console.error('‚ùå [IntervenantsService] Erreur lors de la mise √† jour de l\'intervenant:', error);
      throw error;
    }
  }

  /**
   * Supprime un intervenant et invalide le cache
   */
  async deleteIntervenant(
    intervenantId: string,
    options: IntervenantServiceOptions = {}
  ): Promise<void> {
    console.log('üóëÔ∏è [IntervenantsService] Suppression de l\'intervenant:', intervenantId);

    try {
      // R√©cup√©rer l'intervenant avant suppression pour invalider le cache
      const { data: intervenantData } = await this.supabase
        .from('participants')
        .select('plot_id, created_by')
        .eq('id', intervenantId)
        .single();

      const startTime = Date.now();
      
      const { error } = await this.supabase
        .from('participants')
        .delete()
        .eq('id', intervenantId);

      if (error) {
        console.error('‚ùå [IntervenantsService] Erreur lors de la suppression de l\'intervenant:', error);
        throw error;
      }

      const responseTime = Date.now() - startTime;
      console.log(`‚úÖ [IntervenantsService] Intervenant supprim√© en ${responseTime}ms`);

      // Invalider le cache
      await this.cache.invalidateIntervenantCache(intervenantId);
      if (intervenantData) {
        await this.cache.invalidatePlotCache(intervenantData.plot_id);
        await this.cache.invalidateAgentCache(intervenantData.created_by || '');
      }
    } catch (error) {
      console.error('‚ùå [IntervenantsService] Erreur lors de la suppression de l\'intervenant:', error);
      throw error;
    }
  }

  /**
   * Formate les donn√©es d'un intervenant
   */
  private formatIntervenantData(data: any): Intervenant {
    return {
      id: data.id,
      plot_id: data.plot_id,
      name: data.name,
      role: data.role,
      created_at: data.created_at,
      updated_at: data.updated_at,
      created_by: data.created_by,
      birthdate: data.birthdate,
      cni: data.cni,
      is_young: data.is_young,
      languages: data.languages,
      literacy: data.literacy,
      sex: data.sex
    };
  }

  /**
   * Formate les donn√©es d'un intervenant pour l'affichage
   */
  private formatIntervenantDisplay(intervenant: Intervenant): IntervenantDisplay {
    return {
      id: intervenant.id,
      plot_id: intervenant.plot_id,
      name: intervenant.name,
      role: intervenant.role,
      created_at: intervenant.created_at,
      updated_at: intervenant.updated_at,
      created_by: intervenant.created_by,
      birthdate: intervenant.birthdate,
      is_young: intervenant.is_young,
      languages: intervenant.languages,
      literacy: intervenant.literacy,
      sex: intervenant.sex
    };
  }

  /**
   * Invalide le cache des intervenants d'une parcelle
   */
  async invalidatePlotCache(plotId: string): Promise<void> {
    console.log('üóëÔ∏è [IntervenantsService] Invalidation du cache pour la parcelle:', plotId);
    await this.cache.invalidatePlotCache(plotId);
  }

  /**
   * Invalide le cache des intervenants d'un agent
   */
  async invalidateAgentCache(agentId: string): Promise<void> {
    console.log('üóëÔ∏è [IntervenantsService] Invalidation du cache pour l\'agent:', agentId);
    await this.cache.invalidateAgentCache(agentId);
  }

  /**
   * Invalide tout le cache des intervenants
   */
  async invalidateAllCache(): Promise<void> {
    console.log('üóëÔ∏è [IntervenantsService] Invalidation de tout le cache des intervenants');
    await this.cache.invalidateAllCache();
  }
}

export const IntervenantsServiceInstance = new IntervenantsService();
